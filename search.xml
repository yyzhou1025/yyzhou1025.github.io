<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How to find a job]]></title>
    <url>%2F2018%2F08%2F17%2FHow-to-find-a-job%2F</url>
    <content type="text"><![CDATA[每次刷题总会有刷到一半刷不下去， 觉得自己太渣怎么可能找到工作。想到处找一点精神食粮来鼓励自己，看别人的经验，总要看到这些打了鸡血的文章才有继续刷下去的动力。所以我决定把这些文章都收集在这里，作为我精神粮仓吧！其实看到这些标题真的很像鸡汤啊，但对我来说就是有用。不得不说，信念很重要，我相信我可以做到的事情就一定可以做到。 如何开始找工作 我的弱b记录 三个月刷题拿到Google offer 8个月从cs菜鸟到拿到Google offer的经验 + 内推]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Count Complete Tree Nodes]]></title>
    <url>%2F2018%2F08%2F15%2FCount-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[We need to count the nodes of a complete binary tree, first of all, let’s clarify the defination of three kinds of binary tree: complete binary tree, prefect binary tree and full binary tree. Complete Binary Tree In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes at the last level h. An alternative defination is a prefect tree whose rightmost leaves have been removed. Prefect Binary Tree A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level. Full Binary Tree A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. The nature of binary tree If the level begins from 0, them level i has at most 2^i nodes. If the hight of a binary tree is k, then the tree has at most 2^(k + 1) - 1 nodes (k &gt;= -1). So according to the defination above, a prefect binary tree must be a complete binary tree, but a complete binary tree may not be a prefect binary tree. So the complete binary tree in the question maybe a prefect binary tree. If it’s a prefect binary tree, then the number of nodes is 2^(k + 1) - 1 (k is the level of the tree). We can write recursive code to slove this question. Find the right and left subtree’s height: leftDep and rightDep. If leftDep is equal to rightDep, the it’s a prefect binary tree; else we the sum of the nodes is 1 + the nodes of right subtree + the nodes of left subtree. The code is below:1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; if (root == null) return 0; int leftDep = leftDepth(root); int rightDep = rightDepth(root); if (leftDep == rightDep) return (1 &lt;&lt; leftDep) - 1; else return 1 + countNodes(root.left) + countNodes(root.right); &#125; private int leftDepth(TreeNode root) &#123; int dep = 0; while (root != null) &#123; root = root.left; dep++; &#125; return dep; &#125; private int rightDepth(TreeNode root) &#123; int dep = 0; while (root != null) &#123; root = root.right; dep++; &#125; return dep; &#125;&#125; At the first time, I try to use depth first search, but it failed because time limited exception…]]></content>
      <categories>
        <category>DataStructure</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DataStracture</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <url>%2F2018%2F08%2F14%2FBinary-Tree-Preorder-Inorder-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Yesterday, I solved three binary tree’s problems: LeetCode 94, LeeetCode 144, LeetCode 145. They are about preorder, inorder and postorder traverse. I will sum up using both reversive and iterative solutions. First of all, LeetCode 94 : Binary Tree Inorder Traversal. Recursive solution: 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root != null) &#123; inorderTraversal(root.left); res.add(root.val); inorderTraversal(root.right); &#125; return res; &#125;&#125; Another way using help method to write recursive solution: 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); helper(root, res); return res; &#125; public void helper(TreeNode root, List&lt;Integer&gt; res) &#123; if (root != null) &#123; if (root.left != null) &#123; helper(root.left, res); &#125; res.add(root.val); if (root.right != null) &#123; helper(root.right, res); &#125; &#125; &#125;&#125;Time Complexity: O(n), the time complexity of recursive function is `T(n) = 2 * T(n / 2) + 1`Space Complexity: The worst case space required is O(n), and in the average case it&apos;s O(log(n)), where n is number of node. Iterative solution:1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) &#123; while (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; curr = stack.pop(); list.add(curr.val); curr = curr.right; &#125; return list; &#125;&#125; Time Complexity: O(n) Space Complexity: O(n) Second, leetcode 144: Binary Tree Preorder Traversal. Recursive solution: 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; res.add(root.val); res.addAll(preorderTraversal(root.left)); res.addAll(preorderTraversal(root.right)); return res; &#125;&#125; Iterative Solution: 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; res.add(root.val); stack.push(root); root = root.left; &#125; root = stack.pop(); root = root.right; &#125; return res; &#125;&#125; Finally, leetcode 145 : Binary Tree Postorder Traversal. Recursive Solution: 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; res.addAll(postorderTraversal(root.left)); res.addAll(postorderTraversal(root.right)); res.add(root.val); return res; &#125;&#125; Iterative Solution:123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return res; while(root != null || !stack.isEmpty()) &#123; while (root != null) &#123; res.add(root.val); stack.push(root); root = root.right; &#125; root = stack.pop(); root = root.left; &#125; Collections.reverse(res); return res; &#125;&#125;]]></content>
      <categories>
        <category>DataStructure</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search Tree</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search a 2D Matrix]]></title>
    <url>%2F2018%2F08%2F13%2FSearch-a-2D-Matrix%2F</url>
    <content type="text"><![CDATA[Last time, I summarized binary search in the sorted array. This time I want to summarize binary search in 2D matrix. The question is LeetCode 74 : Search a 2D Matrix. The answer is :123456789101112131415161718192021class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0 || matrix[0].length == 0) return false; int row = matrix.length; int column = matrix[0].length; int start = 0; int end = row * column - 1; while(start &lt;= end) &#123; int mid = start + (end - start) / 2; int midValue = matrix[mid / column][mid % column]; if (midValue &lt; target) &#123; start = mid + 1; &#125; else if (midValue &gt; target) &#123; end = mid - 1; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125; The dificult is to understand how to find midValue: 12int mid = start + (end - start) / 2;int midValue = matrix[mid / column][mid % column]; We can look at an example, change 2D matrix into array:1230, 1, 23, 4, 5 ---&gt; 0, 1, 2, 3, 4, 5, 6, 7, 86, 7, 8 Hence the matrix[i][j] becomes matrix[i * column + j], where i, j = 0, 1, 2, column = 3; Denote i * column + j by mid, then i = mid / column, j = mid % column. Henceint midValue = matrix[mid / column][mid % column];]]></content>
      <categories>
        <category>LeetCode</category>
        <category>BinarySearch</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Top K Frequent Elements]]></title>
    <url>%2F2018%2F08%2F13%2FTop-K-Frequent-Elements%2F</url>
    <content type="text"><![CDATA[Today I want to analyze two medium level LeetCode questions. At first glance, I thought this two questions were simple. However, it took me several hours to really understand. So I write my thoughts here for reviewing afterwards. These two questions are similar, both use HashMap and have to sort the elements according to frequency. The first question is LeetCode 347 :Top Key Frequency Elements. 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i : nums) &#123; map.put(i, map.getOrDefault(i, 0) + 1); &#125; List&lt;Integer&gt;[] list = new List[nums.length + 1]; for (int i : map.keySet()) &#123; if (list[map.get(i)] == null) &#123; list[map.get(i)] = new ArrayList&lt;&gt;(); &#125; list[map.get(i)].add(i); &#125; List&lt;Integer&gt; answer = new ArrayList&lt;&gt;(); for (int pos = list.length - 1; pos &gt;= 0 &amp;&amp; answer.size() &lt; k; pos--) &#123; if (list[pos] != null) &#123; answer.addAll(list[pos]); &#125; &#125; return answer; &#125;&#125; Analysis: map is used to store different elements in nums, the key of map is different elements in nums, the value is the frequency of each elements. Then, create an array of ArrayList, the length of the array is the largest posible frequency of the each element: nums.length + 1 (if there is only one element in the array repeat many time). The rest of the code is easy to understand. The second question is LeetCode 451: Sort Character by Frequency. 123456789101112131415161718192021222324252627class Solution &#123; public String frequencySort(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char i : s.toCharArray()) &#123; map.put(i, map.getOrDefault(i, 0) + 1); &#125; List&lt;Character&gt;[] list = new List[s.length() + 1]; for (char i : map.keySet()) &#123; if(list[map.get(i)] == null) &#123; list[map.get(i)] = new ArrayList&lt;&gt;(); &#125; list[map.get(i)].add(i); &#125; StringBuilder answer = new StringBuilder(); for (int i = list.length - 1; i &gt;= 0; i--) &#123; if (list[i] != null) &#123; for (char k : list[i]) &#123; for (int j = 0; j &lt; map.get(k); j++) &#123; answer.append(k); &#125; &#125; &#125; &#125; return answer.toString(); &#125;&#125; Analysis: The algorithm of the second question is similar.]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>LeetCode</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search Trees]]></title>
    <url>%2F2018%2F08%2F07%2FBinary-Search-Trees%2F</url>
    <content type="text"><![CDATA[It’s a data structure that has the advantages of both ordered array and linked list. Ordered Array: Search in quick using binary search Linked List: Insert and delete items quickly (in the sense that there is no need to shift items) Tree Terminology: Root: The node at the top of the tree. Only one root in a tree! Parent: When any node (except root) has exactly one edge running upward to another node. The node above is called parent of the node. Child: Any node may have one or more lines running downward to other nodes. There nodes below the given node called its child. Leaf: A node with no child. There can be many leaves in a tree. Level(Height): The root is at level 0 and its children are at level 1 and so on. A full binary treeis a binary tree where each node has exactly zero or two children. A complete binary treeis a binary tree that is completely filled in reading (from left to right) each row with the possible exception of the bottom level. We will mainly talk about binary search tree. The defining characteristic, or the ordering invariantm of the binary search tree:At any node with a key value, k, in a binary search tree, all keys of the elements in the left sub-tree must be less than k, while all keys of the elements in the right sub-tree must be greater than k. (Meaning no duplicate keys are allowed) Fitst, let’s have an interface for BST.123456789101112131415161718192021222324252627public interface BSTInterface &#123; /** * Searches for an element with key in the tree. * @param key key value to search * @return boolean value indicating success or failure */ boolean find(int key); /** * Inserts a new element into the tree. * @param key key of the element * @param value value of the element */ void insert(int key, double value); /** * Deletes an element from the tree. * @param key key of the element to be deleted */ void delete(int key); /** * Traverses and prints key and value pairs in the tree. */ void traverse();&#125; To implement the BST, we need Node class as a private static nested class within the BST class.123456789101112private static class Node &#123; private int key; private int value; private Node left, right; Node(int k, double v) &#123; key = k; value = v; left = null; right = null; &#125;&#125; Searching for a giving key1234567891011121314151617public boolean find(int key) &#123; if (root == null) &#123; return false; &#125; Node current = root; while (current.key != key) &#123; if (current.key &lt; key) &#123; current = current.right; &#125; else &#123; current = current.left; &#125; if (current == null) &#123; return false; &#125; &#125; return true;&#125; Inserting a new item1234567891011121314151617181920212223242526272829public void insert(int key, double value) &#123; Node newNode = new Node (key, value); if (root == null) &#123; root = newNode; return; &#125; Node parent = root; Node current = root; while(true) &#123; if (current.key == key) &#123; return; &#125; parent = current; if (current.key &lt; key) &#123; current = current.right; if (current == null )&#123; parent.right = newNode; return; &#125; &#125; else &#123; current = current.left; if (current == null) &#123; parent.left = newNode; return; &#125; &#125; &#125;&#125; Deleting an itemDeleting an item is more complicated than other operations.To delete, we start by searching the node(using key), after searching, there are four cases for us to consider: CASE1: The node is not in the tree CASE2: The node is a leaf CASE3: The node has one child CASE4: The node has two children CASE1: not found1234567891011121314151617181920public void delete(int key) &#123; Node parent = root; // keep track of the parent Node current = root; // keep track of the current if (root == null) return; boolean isLC = true // is left child while (current.key != key) &#123; parent = current; if(current.key &lt; key) &#123; isLC = false; current = current.right; &#125; else &#123; isLC = true; current = current.left; &#125; //case1 : not found if (current == null) &#123; return; &#125; &#125; CASE2: a leaf123456789if (current.left == null &amp;&amp; current.right == null) &#123; if (current == root) &#123; root = null &#125; else if (isLC) &#123; parent.left = null; &#125; else if (!isLC) &#123; parent.right = null; &#125;&#125; CASE3: a node with one child1234567891011121314151617&#125; else if (current.right == null) &#123; if (current == root) &#123; root = current.left; &#125; else if (isLC) &#123; parent.left = current.left; &#125; else &#123; parent.right = current.left; &#125;&#125; else if (current.left == null) &#123; if (current == root) &#123; root = current.right; &#125; else if (isLC) &#123; parent.left = current.right; &#125; else &#123; parent.right = current.right; &#125;&#125; CASE4: a node with two childrenFor case 4, we need to find the successor to replace the deleted one. Basically, the successor is the smallest node(key) in the right sub-tree of the node to be deleted. Find the successor12345678910111213141516171819//method to find the successorpublic Node getSuccessor(Node toDelete) &#123; Node sp = toDelete; Node successor = toDelete; Node current = toDelete.right; while(current != null) &#123; sp = successor; successor = current; current = current.left; &#125; //if the successor is not the right child of toDelete if (successor != toDelete.right) &#123; sp.left = successor.right; successor.right = toDelete.right; &#125; return successor;&#125; Now it’s time to finish case41234567891011&#125; else &#123; Node successor = getSuccessor(current); if (current = root) &#123; root = successor; &#125; else if (isLC) &#123; parent.left = successor; &#125; else &#123; parent.right = successor; &#125; successor.left = current.left;&#125; Traversing a BSTThis means visiting each node in a specific order.There are three simple ways to traverse a tree: preorder, inorder and postorder. Preorder: PLR(Parent, Left, Right) Inorder: LPR (ascending order) Postorder: LRPEXERCISE123inorder: 14, 21, 35, 43, 56, 67preorder: 43, 21, 14, 35, 56, 67postorder: 14, 35, 21, 67, 56, 43 Below is the code for inorder traversal of the tree123456789101112// inorder traversal of the treepublic void traverse() &#123; inorderHelper(root);&#125;private void inOrderHelper(Node toVisit) &#123; if (toVisit != null) &#123; inOrderHelper(toVisit.left); System.out.println(toVisit); inOrderHelper(toVisit.right); &#125;&#125;]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F08%2F07%2FBinary-Search%2F</url>
    <content type="text"><![CDATA[Prerequisite for the binary search: The array should be ordered !First of all, let’s look at an example to help us understand the process of binary search. Let’s say we want to search for -1 in a given array [-34, -23, -9, -1, 5, 7, 8, 9, 34, 68, 88, 99].Set initial variables: upperBound = array.length - 1; // 11 lowerBound = 0; //0 mid = (upperBound + lowerBound) / 2; // 5 Compare -1 with the middle element at index 5, which is 7. Since -1 &lt; 7, then we change the upperBound to (mid - 1), so 123upperBound = mid - 1; // 4//lowerBound is still 0mid = (upperBound + lowerBound) / 2; // 2 Compare -1 with the middle element at index 2, which is -9. Since -1 &gt; -9, then we change the lowerBound to (mid + 1), so 123//upperBound is still 4lowerBound = mid + 1; // 3mid = (upperBound + lowerBound) / 2; // 3 Compare -1 with the middle element at index 3, is -1 ! Bingo! We found it! Time to get out hands dirty by implementing the binary search!123456789101112131415161718public static int binarySearch(int[] data, int key) &#123; int lowerBound = 0; int upperBound = data.length - 1; int mid; while(true) &#123; if(lowerBound &gt; upperBound) return -1; mid = lowerBound + (upperBound -lowerBound) / 2; // why not use (upperBound + lowerBound) / 2 ? Because (upperBound + lowerBound) may exceed the range of integer(overflow) if (data[mid] == key) &#123; return mid; &#125; if (data[mid] &lt; key) &#123; lowerBound = mid + 1; &#125; else &#123; upperBound = mid - 1; &#125; &#125;&#125; Binary search Big O : O(log n)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack and Queue]]></title>
    <url>%2F2018%2F08%2F07%2FStack-and-Queue%2F</url>
    <content type="text"><![CDATA[A limited data structure and LIFO A stack is a container of objects that are inserted or removed according to the last-in first-out (LIFO) principle.Simply speaking, there are two major operations: Push: push an item onto the top of the stack Pop: pop the item from the top of the stack A stack is built on top of other data structures. It could be an array, an ArrayList, or a LiknedList. But, the most important thing is that we want a Stack to have the same functionalities no matter what underlying data structure it relies on. For what, we need a Stack Interface. Array-based implementationWe need three fields for this implementation: An array elements which has a fixed capacity. Variable top that refers to the top item in the stack. Constant DEFAULTCAPACITY that refers to the default array length. Here are the implementation of the stack. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@SuppressWarnings(&quot;hiding&quot;)public class ArrayStack&lt;AnyType&gt; implements StackInterface&lt;AnyType&gt; &#123; private static final int DEFAULTCAPACITY = 10; private int top; private Object[] elements; public ArrayStack(int initialCapacity) &#123; if (initialCapacity &lt;= 0) &#123; elements = new Object[DEFAULTCAPACITY]; &#125; else &#123; elements = new Object[initialCapacity]; &#125; //set the top to be -1, indicating the stack is empty top = -1; &#125; public ArrayStack() &#123; this(DEFAULTCAPACITY); &#125; /** * Insert a new item onto the top of the stack. * @throws Exception */ @Override public void push(AnyType item) &#123; if (top == elements.length - 1) &#123; throw new RuntimeException(&quot;Stack is full&quot;); &#125; elements[top + 1] = item; &#125; /** * Remove and returns the item at the top. */ @Override public AnyType pop() &#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;Empty&quot;); &#125; //get the element on the top @SuppressWarnings(&quot;unchecked&quot;) AnyType item = (AnyType) elements[top]; elements[top] = null; top--; return item; &#125; /** * Return top item without removing it. */ @SuppressWarnings(&quot;unchecked&quot;) @Override public AnyType peek() &#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;Empty&quot;); &#125; return (AnyType) elements[top]; &#125; @Override public boolean isEmpty() &#123; return top == -1; &#125; If you want to build up a new stack, you can: Stack&lt;AnyType&gt; stack = new Stack&lt;&gt;() Another limited data structure and FIFO A queue is a container of objects that are inserted and removed based on FIFO (First-in First-out) principle.In a queue, there are two major operations, enqueue and dequeue. Enqueue means inserting a new item to the back of the queue. Dequeue means removing the first item from the queue. First of all, we can have an interface of a queue. 123456public interface QueueInterface&lt;AnyType&gt; &#123; void enqueue(AnyType item); // O(1) AnyType dequeue(); // O(1) AnyType peekFront(); // O(1) boolean isEmpty(); // O(1)&#125; Array-based implementationWe need some fields: An “array elements” which has a fixed length Variable “back” that refers to the back of the queue Variable “front” that refers to the front of the queue Additionally, “nItems” variable to keep track of current number of items Every time a new item is added(enqueued), the “back” index should be increased. And when the front item is removed(dequeued), the “front” index should also be ## INCREASED ##. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ArrayQueue&lt;AnyType&gt; implements QueueInterface&lt;AnyType&gt; &#123; private static fianl int DEFAULTCAPACITY = 6; private Object[] elements; private int front; // front index private int back; // back index private int nItems; // current number of items public ArrayQueue() &#123; elements = new Object[DEFAULTCAPACITY]; front = 0; back = -1; nItems = 0; &#125; /** * Inserts a new item into the back of the queue. * @param e the new item to be inserted. */ @Override public void enqueue(AnyType item) &#123; if (isFull()) &#123; throw new RuntimeException(&quot;Queue is full&quot;); &#125; back++; int index = (back) % elements.length; elements[index] = item; nItems++; &#125; /** * Returns and removes the item at the front. * @return the item at the front of the queue * @throws NoSuchElementException if it is empty */ @Override public AnyType dequeue() &#123; if (isEmpty()) &#123; throw new NoSuchElementException(); &#125; int index = front % elements.length; @SuppressWarnings(&quot;unchecked&quot;) AnyType result = (AnyType) elements[index]; elements[index] = null; // remove it front = front + 1; nItems--; // one less in the queue return result; &#125; /** * Returns the first item in the queue without removing it. * @return the first item * @throws NoSuchElementException if it is empty */ @SuppressWarnings(&quot;unchecked&quot;) @Override public AnyType peekFront() &#123; if (isEmpty()) &#123; throw new NoSuchElementException(); &#125; return (AnyType) elements[front % elements.length]; &#125; @Override public boolean isEmpty() &#123; return nItems == 0; &#125; If you want to build up a new queue, you can:Queue&lt;AnyType&gt; myQueue = new LinkedList&lt;&gt;();]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2018%2F08%2F05%2FMy-first-blog%2F</url>
    <content type="text"><![CDATA[This is a test blog!I will write my solutions and thoughts for some hard leetcode problems in order to review!Maybe I will write some other projects in the next semester !Welcome to read my blog :)]]></content>
  </entry>
</search>
