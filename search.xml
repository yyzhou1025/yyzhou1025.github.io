<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Top K Frequent Elements]]></title>
    <url>%2F2018%2F08%2F13%2FTop-K-Frequent-Elements%2F</url>
    <content type="text"><![CDATA[Today I want to analyze two medium level LeetCode questions. At first glance, I thought this two questions were simple. However, it took me several hours to really understand. So I write my thoughts here for reviewing afterwards. These two questions are similar, both use HashMap and have to sort the elements according to frequency. The first question is LeetCode 347 :Top Key Frequency Elements.![] (leetcode347.png); 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i : nums) &#123; map.put(i, map.getOrDefault(i, 0) + 1); &#125; List&lt;Integer&gt;[] list = new List[nums.length + 1]; for (int i : map.keySet()) &#123; if (list[map.get(i)] == null) &#123; list[map.get(i)] = new ArrayList&lt;&gt;(); &#125; list[map.get(i)].add(i); &#125; List&lt;Integer&gt; answer = new ArrayList&lt;&gt;(); for (int pos = list.length - 1; pos &gt;= 0 &amp;&amp; answer.size() &lt; k; pos--) &#123; if (list[pos] != null) &#123; answer.addAll(list[pos]); &#125; &#125; return answer; &#125;&#125; Analysis: map is used to store different elements in nums, the key of map is different elements in nums, the value is the frequency of each elements. Then, create an array of ArrayList, the length of the array is the largest posible frequency of the each element: nums.length + 1 (if there is only one element in the array repeat many time). The rest of the code is easy to understand. The second question is LeetCode 451: Sort Character by Frequency.![] (leetcode451.png);123456789101112131415161718192021222324252627class Solution &#123; public String frequencySort(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char i : s.toCharArray()) &#123; map.put(i, map.getOrDefault(i, 0) + 1); &#125; List&lt;Character&gt;[] list = new List[s.length() + 1]; for (char i : map.keySet()) &#123; if(list[map.get(i)] == null) &#123; list[map.get(i)] = new ArrayList&lt;&gt;(); &#125; list[map.get(i)].add(i); &#125; StringBuilder answer = new StringBuilder(); for (int i = list.length - 1; i &gt;= 0; i--) &#123; if (list[i] != null) &#123; for (char k : list[i]) &#123; for (int j = 0; j &lt; map.get(k); j++) &#123; answer.append(k); &#125; &#125; &#125; &#125; return answer.toString(); &#125;&#125; Analysis: The algorithm of the second question is similiar.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>heap</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search Trees]]></title>
    <url>%2F2018%2F08%2F07%2FBinary-Search-Trees%2F</url>
    <content type="text"><![CDATA[It’s a data structure that has the advantages of both ordered array and linked list. Ordered Array: Search in quick using binary search Linked List: Insert and delete items quickly (in the sense that there is no need to shift items) Tree Terminology: Root: The node at the top of the tree. Only one root in a tree! Parent: When any node (except root) has exactly one edge running upward to another node. The node above is called parent of the node. Child: Any node may have one or more lines running downward to other nodes. There nodes below the given node called its child. Leaf: A node with no child. There can be many leaves in a tree. Level(Height): The root is at level 0 and its children are at level 1 and so on. A full binary treeis a binary tree where each node has exactly zero or two children. A complete binary treeis a binary tree that is completely filled in reading (from left to right) each row with the possible exception of the bottom level. We will mainly talk about binary search tree. The defining characteristic, or the ordering invariantm of the binary search tree:At any node with a key value, k, in a binary search tree, all keys of the elements in the left sub-tree must be less than k, while all keys of the elements in the right sub-tree must be greater than k. (Meaning no duplicate keys are allowed) Fitst, let’s have an interface for BST.123456789101112131415161718192021222324252627public interface BSTInterface &#123; /** * Searches for an element with key in the tree. * @param key key value to search * @return boolean value indicating success or failure */ boolean find(int key); /** * Inserts a new element into the tree. * @param key key of the element * @param value value of the element */ void insert(int key, double value); /** * Deletes an element from the tree. * @param key key of the element to be deleted */ void delete(int key); /** * Traverses and prints key and value pairs in the tree. */ void traverse();&#125; To implement the BST, we need Node class as a private static nested class within the BST class.123456789101112private static class Node &#123; private int key; private int value; private Node left, right; Node(int k, double v) &#123; key = k; value = v; left = null; right = null; &#125;&#125; Searching for a giving key1234567891011121314151617public boolean find(int key) &#123; if (root == null) &#123; return false; &#125; Node current = root; while (current.key != key) &#123; if (current.key &lt; key) &#123; current = current.right; &#125; else &#123; current = current.left; &#125; if (current == null) &#123; return false; &#125; &#125; return true;&#125; Inserting a new item1234567891011121314151617181920212223242526272829public void insert(int key, double value) &#123; Node newNode = new Node (key, value); if (root == null) &#123; root = newNode; return; &#125; Node parent = root; Node current = root; while(true) &#123; if (current.key == key) &#123; return; &#125; parent = current; if (current.key &lt; key) &#123; current = current.right; if (current == null )&#123; parent.right = newNode; return; &#125; &#125; else &#123; current = current.left; if (current == null) &#123; parent.left = newNode; return; &#125; &#125; &#125;&#125; Deleting an itemDeleting an item is more complicated than other operations.To delete, we start by searching the node(using key), after searching, there are four cases for us to consider: CASE1: The node is not in the tree CASE2: The node is a leaf CASE3: The node has one child CASE4: The node has two children CASE1: not found1234567891011121314151617181920public void delete(int key) &#123; Node parent = root; // keep track of the parent Node current = root; // keep track of the current if (root == null) return; boolean isLC = true // is left child while (current.key != key) &#123; parent = current; if(current.key &lt; key) &#123; isLC = false; current = current.right; &#125; else &#123; isLC = true; current = current.left; &#125; //case1 : not found if (current == null) &#123; return; &#125; &#125; CASE2: a leaf123456789if (current.left == null &amp;&amp; current.right == null) &#123; if (current == root) &#123; root = null &#125; else if (isLC) &#123; parent.left = null; &#125; else if (!isLC) &#123; parent.right = null; &#125;&#125; CASE3: a node with one child1234567891011121314151617&#125; else if (current.right == null) &#123; if (current == root) &#123; root = current.left; &#125; else if (isLC) &#123; parent.left = current.left; &#125; else &#123; parent.right = current.left; &#125;&#125; else if (current.left == null) &#123; if (current == root) &#123; root = current.right; &#125; else if (isLC) &#123; parent.left = current.right; &#125; else &#123; parent.right = current.right; &#125;&#125; CASE4: a node with two childrenFor case 4, we need to find the successor to replace the deleted one. Basically, the successor is the smallest node(key) in the right sub-tree of the node to be deleted. Find the successor12345678910111213141516171819//method to find the successorpublic Node getSuccessor(Node toDelete) &#123; Node sp = toDelete; Node successor = toDelete; Node current = toDelete.right; while(current != null) &#123; sp = successor; successor = current; current = current.left; &#125; //if the successor is not the right child of toDelete if (successor != toDelete.right) &#123; sp.left = successor.right; successor.right = toDelete.right; &#125; return successor;&#125; Now it’s time to finish case41234567891011&#125; else &#123; Node successor = getSuccessor(current); if (current = root) &#123; root = successor; &#125; else if (isLC) &#123; parent.left = successor; &#125; else &#123; parent.right = successor; &#125; successor.left = current.left;&#125; Traversing a BSTThis means visiting each node in a specific order.There are three simple ways to traverse a tree: preorder, inorder and postorder. Preorder: PLR(Parent, Left, Right) Inorder: LPR (ascending order) Postorder: LRPEXERCISE123inorder: 14, 21, 35, 43, 56, 67preorder: 43, 21, 14, 35, 56, 67postorder: 14, 35, 21, 67, 56, 43 Below is the code for inorder traversal of the tree123456789101112// inorder traversal of the treepublic void traverse() &#123; inorderHelper(root);&#125;private void inOrderHelper(Node toVisit) &#123; if (toVisit != null) &#123; inOrderHelper(toVisit.left); System.out.println(toVisit); inOrderHelper(toVisit.right); &#125;&#125;]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F08%2F07%2FBinary-Search%2F</url>
    <content type="text"><![CDATA[Prerequisite for the binary search: The array should be ordered !First of all, let’s look at an example to help us understand the process of binary search. Let’s say we want to search for -1 in a given array [-34, -23, -9, -1, 5, 7, 8, 9, 34, 68, 88, 99].Set initial variables: upperBound = array.length - 1; // 11 lowerBound = 0; //0 mid = (upperBound + lowerBound) / 2; // 5 Compare -1 with the middle element at index 5, which is 7. Since -1 &lt; 7, then we change the upperBound to (mid - 1), so 123upperBound = mid - 1; // 4//lowerBound is still 0mid = (upperBound + lowerBound) / 2; // 2 Compare -1 with the middle element at index 2, which is -9. Since -1 &gt; -9, then we change the lowerBound to (mid + 1), so 123//upperBound is still 4lowerBound = mid + 1; // 3mid = (upperBound + lowerBound) / 2; // 3 Compare -1 with the middle element at index 3, is -1 ! Bingo! We found it! Time to get out hands dirty by implementing the binary search!123456789101112131415161718public static int binarySearch(int[] data, int key) &#123; int lowerBound = 0; int upperBound = data.length - 1; int mid; while(true) &#123; if(lowerBound &gt; upperBound) return -1; mid = lowerBound + (upperBound -lowerBound) / 2; // why not use (upperBound + lowerBound) / 2 ? Because (upperBound + lowerBound) may exceed the range of integer(overflow) if (data[mid] == key) &#123; return mid; &#125; if (data[mid] &lt; key) &#123; lowerBound = mid + 1; &#125; else &#123; upperBound = mid - 1; &#125; &#125;&#125; Binary search Big O : O(log n)]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack and Queue]]></title>
    <url>%2F2018%2F08%2F07%2FStack-and-Queue%2F</url>
    <content type="text"><![CDATA[A limited data structure and LIFO A stack is a container of objects that are inserted or removed according to the last-in first-out (LIFO) principle.Simply speaking, there are two major operations: Push: push an item onto the top of the stack Pop: pop the item from the top of the stack A stack is built on top of other data structures. It could be an array, an ArrayList, or a LiknedList. But, the most important thing is that we want a Stack to have the same functionalities no matter what underlying data structure it relies on. For what, we need a Stack Interface. Array-based implementationWe need three fields for this implementation: An array elements which has a fixed capacity. Variable top that refers to the top item in the stack. Constant DEFAULTCAPACITY that refers to the default array length. Here are the implementation of the stack. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@SuppressWarnings(&quot;hiding&quot;)public class ArrayStack&lt;AnyType&gt; implements StackInterface&lt;AnyType&gt; &#123; private static final int DEFAULTCAPACITY = 10; private int top; private Object[] elements; public ArrayStack(int initialCapacity) &#123; if (initialCapacity &lt;= 0) &#123; elements = new Object[DEFAULTCAPACITY]; &#125; else &#123; elements = new Object[initialCapacity]; &#125; //set the top to be -1, indicating the stack is empty top = -1; &#125; public ArrayStack() &#123; this(DEFAULTCAPACITY); &#125; /** * Insert a new item onto the top of the stack. * @throws Exception */ @Override public void push(AnyType item) &#123; if (top == elements.length - 1) &#123; throw new RuntimeException(&quot;Stack is full&quot;); &#125; elements[top + 1] = item; &#125; /** * Remove and returns the item at the top. */ @Override public AnyType pop() &#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;Empty&quot;); &#125; //get the element on the top @SuppressWarnings(&quot;unchecked&quot;) AnyType item = (AnyType) elements[top]; elements[top] = null; top--; return item; &#125; /** * Return top item without removing it. */ @SuppressWarnings(&quot;unchecked&quot;) @Override public AnyType peek() &#123; if (isEmpty()) &#123; throw new RuntimeException(&quot;Empty&quot;); &#125; return (AnyType) elements[top]; &#125; @Override public boolean isEmpty() &#123; return top == -1; &#125; If you want to build up a new stack, you can: Stack&lt;AnyType&gt; stack = new Stack&lt;&gt;() Another limited data structure and FIFO A queue is a container of objects that are inserted and removed based on FIFO (First-in First-out) principle.In a queue, there are two major operations, enqueue and dequeue. Enqueue means inserting a new item to the back of the queue. Dequeue means removing the first item from the queue. First of all, we can have an interface of a queue. 123456public interface QueueInterface&lt;AnyType&gt; &#123; void enqueue(AnyType item); // O(1) AnyType dequeue(); // O(1) AnyType peekFront(); // O(1) boolean isEmpty(); // O(1)&#125; Array-based implementationWe need some fields: An “array elements” which has a fixed length Variable “back” that refers to the back of the queue Variable “front” that refers to the front of the queue Additionally, “nItems” variable to keep track of current number of items Every time a new item is added(enqueued), the “back” index should be increased. And when the front item is removed(dequeued), the “front” index should also be ## INCREASED ##. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ArrayQueue&lt;AnyType&gt; implements QueueInterface&lt;AnyType&gt; &#123; private static fianl int DEFAULTCAPACITY = 6; private Object[] elements; private int front; // front index private int back; // back index private int nItems; // current number of items public ArrayQueue() &#123; elements = new Object[DEFAULTCAPACITY]; front = 0; back = -1; nItems = 0; &#125; /** * Inserts a new item into the back of the queue. * @param e the new item to be inserted. */ @Override public void enqueue(AnyType item) &#123; if (isFull()) &#123; throw new RuntimeException(&quot;Queue is full&quot;); &#125; back++; int index = (back) % elements.length; elements[index] = item; nItems++; &#125; /** * Returns and removes the item at the front. * @return the item at the front of the queue * @throws NoSuchElementException if it is empty */ @Override public AnyType dequeue() &#123; if (isEmpty()) &#123; throw new NoSuchElementException(); &#125; int index = front % elements.length; @SuppressWarnings(&quot;unchecked&quot;) AnyType result = (AnyType) elements[index]; elements[index] = null; // remove it front = front + 1; nItems--; // one less in the queue return result; &#125; /** * Returns the first item in the queue without removing it. * @return the first item * @throws NoSuchElementException if it is empty */ @SuppressWarnings(&quot;unchecked&quot;) @Override public AnyType peekFront() &#123; if (isEmpty()) &#123; throw new NoSuchElementException(); &#125; return (AnyType) elements[front % elements.length]; &#125; @Override public boolean isEmpty() &#123; return nItems == 0; &#125; If you want to build up a new queue, you can:Queue&lt;AnyType&gt; myQueue = new LinkedList&lt;&gt;();]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2018%2F08%2F05%2FMy-first-blog%2F</url>
    <content type="text"><![CDATA[This is a test blog!I will write my solutions and thoughts for some hard leetcode problems in order to review!Maybe I will write some other projects in the next semester !Welcome to read my blog :)]]></content>
  </entry>
</search>
